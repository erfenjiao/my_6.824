# 互联网规模系统的无等待协调

## 摘要

ZooKeeper: 一个用与协调分布式应用进程的服务,ZooKeeper是关键基础设施的一部分,旨在提供一个简单和高性能的内核,以便在客户端建立更复杂的协调原语.



他将群组消息传递 , 分布式锁服务和共享寄存器的元素整合到一个重复的集中式服务中



**ZooKeeper接口**

1. 具有共享寄存器的免等待功能,以及类似于分布式文件系统的缓冲失效的事件驱动机制,以提供简单而强大的协调服务
2. 接口能够实现高性能服务
3. 能够为客户端提供先进先出的请求保证
4. 为所有改变ZooKeeper状态的再请求提供线性化

这些特性使我们能够实现一个高性能的处理管道,读取请求由本地服务器完成

## 1. 简介

1. 大规模分布式系统需要不同形式的协调,配置是协调的基本形式之一.

在最简单的形式中,配置是系统进程的操作参数列表,而更复杂的系统有动态配置参数

2. 锁构成一个强大的协调元素,实现对关键再资源的互斥性访问
3. 协调服务: 为了协调,可以为不同的协调需求开发服务

> 例如亚马逊简单队列服务就特别关注排队问题
>
> 还有专门用于领导者选举和配置
>
> 还可以用强大的服务要素实现不太强大的要素

ZooKeeper在设计服务时,

1. 选择暴露一个API,使应用开发者能够实现他们自己的基元,这样的选择导致了协调内核的实现
2. 抛弃了阻塞原语,如,锁

为了实现协调原语:

1. 无等待属性使我们的系统具有良好的性能和容错性
2. 保证所有先进先出的客户端顺序和可写入能够有效地实现服务



## 2 ZooKeeper服务

包括一个使用复制的服务群,以实现高可用性和性能.

> 它的高性能可以使由大量进程组成的应用程序能够使用这样一个协调内核来实现管理

使用简单的流水线结构来实现,它允许我们在有成百上千的请求下仍可以保持低延迟. 

这样的流水线自然可以以先进先出的顺序执行来自单个客户端的操作.

保证先进先出的客户端顺序使客户端能够异步的提交操作

> ?:异步?一瞬间有多个操作?

客户端通过API使用ZooKeeper客户端库向ZooKeeper提交请求

> ​                 API                                             提交请求
>
> 客户端   --------->ZooKeeper客户端库 ------------------> ZooKeeper
>
> ​                                 (负责网络连接)

### 术语

**客户端** : ZooKeeper服务的用户

**服务器** : ZooKeeper服务的进程

**znode** : ZooKeeper数据中的一个内存数据节点,它被组织在一个被称为数据树的分层命名空间中

**术语更新和写入** : 指代任何修改数据树状态的操作

> 分层命名空间: 类似于文件系统目录树

客户端在连接到ZooKeeper时建立一个会话,并获得一个会话句柄,通过它来发送请求

### 2.1 服务概述

ZooKeeper 实现了视察,已允许客户端在不需要轮询的情况下,及时收到变化通知.

#### znodes的两种类型

##### 常规

客户端通过明确的创建和删除正规的znodes来操纵他们

##### 短暂的

客户端创建他们,可以明确的删除,或者在创建他们的会话终止后,让系统自动删除

#### 数据模型

1. 

ZooKeeper的数据模型基本上是一个具有简单API的文件系统,只有完整的数据读写,或者是一个具有层次的键值表.

分层命名空间对于定位不同应用的命名空间的子树以及设置对这谢子树的访问权限非常有用.

还能利用客户端的目录概念建立更高层次的基元

2. 

Znodes 不是为了一般的数据存储而设计的.相反,Znodes映射到客户端应用程序的缩写,通常对应于协调目的的元数据

> ?: 映射? 缩写?协调目的? 元数据?

尽管Znodes 不是为了一般的数据存储而设计的,但它确实允许客户端存储一些信息

#### 会话

1. 有超时时间

2. 在一个会话中,客户端观察到一系列反应其操作执行情况的状态变化
3. 会话使客户端能够在ZooKeeper集合中透明的从一个服务器移动到另一个服务器,并因此在服务器之间持续存在

> ? : 服务器之间?持续存在?

### 2.2 客户端API

下面介绍ZooKeeper API 的一个相关子集,并讨论每个请求的语义

#### 1. **create(path, data, flags)**

创建一个具有路径名称path的znode，在其中存储data[]，并返回新znode的名称。flags使客户能够选择znode的类型：常规的、短暂的，并设置顺序标志。

#### 2. **delete(path, version)** 

删除znode的路径，如果该znode处于预期的版本。

#### 3. existstence(path, watch)

如果znode路径名path存在，则返回true，否则返回false。watch标志使客户端可以对该znode设置awatch。

#### 4. **getData(path, watch)** 

元数据，例如版本信息。
与节点相关的数据和元数据，如版本信息。watch标志的作用与exists()的方式是一样的，只是如果znode不存在，ZooKeeper不会设置watch。

#### 5. **setData(path, data, version)**

写入data[] 到 znode path，如果版本号是当前版本的znode,则将data[]写到znode路径

#### 6. **getChildren(path, watch)**

返回子节点的名称集合 sync(path)。等待所有在操作开始时等待的更新的所有更新都会传播到客户端所连接的服务器上。目前路径被忽略。

-----------------

所有的方法都有一个同步和一个非同步的方法

当一个应用程序需要执行一个单一的ZooKeeper操作时，并且没有并发的任务要执行时,它就会使用同步API,所以它要进行必要的 ZooKeeper调用并阻断。然而，异步API使应用程序能够同时拥有多个未完成的ZooKeeper操作和其他任务并行执行。ZooKeeper客户端保证每个操作的相应回调被依次调用。

请注意，ZooKeeper不使用句柄来访问znodes。每个请求都包括被操作的znode的完整路径。这种选择不仅简化了API（没有open()或close()方法）。而且它也消除了服务器需要维护的额外状态。

> ? : 用句柄来访问?

每个更新方法都需要一个预期的版本号，这使得有条件的更新得以实现。如果znode的实际版本号与预期的版本号不一致，更新就会以一个意外的版本错误而失败。如果版本号码是-1，它不执行版本检查。

### 2.3 ZooKeeper 的保证

ZooKeeper有两个排序的保证:

1. 可线性化的写入

> 所有更新ZooKeeper状态的请求都是可序列化的

2. 先进先出的客户顺序

> 来自一个特定客户的所有请求都按照客户发送的顺序执行

#### 两种保证是如何作用的

一种情况:

一个由若干进程组成的系统选出一个领导者来指挥工人进程,当一个新的领导者负责该系统时,他必须改变大量的配置参数,并在完成后通知其他进程.这样我们就有两个重要的请求

1. 当新的领导者开始进行改变时,我们不希望其他进城去使用正在改变的配置
2. 若新的领导者在配置更新之前就完全死亡,我们不希望进程使用这个部分的配置

> Chubby提供的锁可以满足第一个要求,但不足以满足第二个

在ZooKeeper中,新的领导者可以指定一个路径作为就绪的Znode;其他进程只有在Znode存在时才会使

用该配置

新的领导者通过删除ready,更新各种配置节点,并创建ready来进行配置变更.

所有的这些变化都可以通过流水线和异步发布来快速更新配置状态

由于排序的保证，如果一个进程看到了就绪的znode，它也必须看到所有由新领导做出的配置改变。如果新的领导者在准备好的Znode被创建之前就死了，其他进程就会知道配置还没有被创建。
其他进程知道该配置还没有被最终确定，就不会使用它

#### 当客户端在ZooKeeper之外还有自己的通信管道

当客户端在ZooKeeper之外还有自己的沟通渠道时，会出现另一个问题。
例如，考虑到两个客户端A和B有一个共享的配置，并通过一个
共享的通信通道进行通信。如果A改变了ZooKeeper中的共享配置，并通过共享通信通道告诉B这一变化 , B就会在重新读取配置时看到这个变化。
如果B的ZooKeeper副本稍稍落后于A的，它可能会不看到新的配置。利用上述保证措施，B可以在重新读取配置前发出写入指令来确保它看到最新的信息。
为了更有效地处理这种情况，ZooKeeper提供了同步请求：当紧随其后的是读,构成一个**慢速读取**。
同步使服务器在处理读之前应用所有待处理的写请求，而不需要完全写的开销。这个基元与ISIS[5]的flush原语的想法相似。

> 这是什么过程

ZooKeeper也有以下两种有效性和持久性保证：如果大多数ZooKeeper服务器处于活动状态并进行通信，该服务将是可用的；如果ZooKeeper服务成功响应了如果ZooKeeper服务成功地响应了一个变更请求，只要有一个法定的服务器最终能够恢复，该变更在任何数量的故障中都会持续存在。

### 2.4 基元的例子

使用ZooKeeper的API实现强大的原语













